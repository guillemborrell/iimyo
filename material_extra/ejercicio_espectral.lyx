#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{a4wide}
\end_preamble
\language spanish
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize 10
\spacing single
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language swedish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\end_header

\begin_body

\begin_layout Title
Ejercicio extra.
 Curso de Matlab
\end_layout

\begin_layout Author
Guillem Borrell i Nogueras
\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard
Los métodos espectrales son útiles cuando se busca una gran precisión en
 problemas de contorno.
 Por ejemplo, tomemos esta ecuación diferencial no lineal
\begin_inset Formula \[
L(u)=u_{xx}-(x^{6}+3x^{2})u=0\]

\end_inset

con condiciones de contorno:
\begin_inset Formula \[
u(-1)=u(1)=1\]

\end_inset


\end_layout

\begin_layout Standard
¿Cómo podemos resolver esta ecuación diferencial? Podríamos utilizar un
 esquema de diferencias finitas.
 Sería sencillo pero...
 ¿Quien ha dicho que vamos a escoger el método más sencillo?
\end_layout

\begin_layout Standard
Uno de los objetivos de este ejercicio es realizar una breve introducción
 práctica a los métodos espectrales de resolución de ecuaciones diferenciales.
 Son más complicados y específicos pero más precisos y una herramienta más
 potente en manos expertas.
\end_layout

\begin_layout Standard
Los métodos espectrales se basan en descomponer la solución en una suma
 de funciones base que, multiplicadas por una serie de coeficientes, aproxima
 la solución:
\begin_inset Formula \[
u_{N}=\sum_{i=0}^{N}a_{i}\phi_{i}(x)\]

\end_inset

Definimos el residuo como la diferencia entre la solución exacta y la aproximada
 por nuestro desarrollo:
\begin_inset Formula \[
R(x;a_{i})=u(x)-u_{N}(x;a_{i})\]

\end_inset


\end_layout

\begin_layout Standard
Los métodos espectrales intentan reducir el residuo en lo posible.
 Para ello se calcula
\begin_inset Formula \[
R(x;a_{i})=\partial_{xx}u_{N}-(x^{6}+3x^{2})u_{N}\]

\end_inset

e iguala el residuo a cero en determinados puntos del dominio.
 Esta técnica se llama método 
\emph on
Pseudoespectral
\emph default
 o de 
\emph on
Colocación
\emph default
.
\end_layout

\begin_layout Standard
Vamos a intentar resolver la ecuación anterior mediante un método pseudoespectra
l utilizando una base de funciones del tipo:
\begin_inset Formula \[
u_{N}(x;a_{i})=1+(1-x^{2})(a_{0}+a_{1}x+a_{2}x^{2}+\cdots+a_{N}x^{N})\]

\end_inset


\end_layout

\begin_layout Standard
Si nos fijamos, la elección del desarrollo tiene bastante lógica.
 Es un término constante acorde con las condiciones de contorno, una función
 que asegura que las condiciones de contorno se cumplan siempre y un desarrollo
 polinómico de potencias pares porque se deduce de la ecuación que la solución
 será simétrica.
\end_layout

\begin_layout Standard
Con esta solución calcularemos el residuo y lo igualaremos a cero en los
 puntos de Gauss-Chebyshev:
\begin_inset Formula \[
x_{i}=cos\left(\frac{(2i-1)\pi}{2N}\right)\]

\end_inset


\end_layout

\begin_layout Section
Algoritmo.
\end_layout

\begin_layout Standard
Implementar el algoritmo no es tan difícil, lo que es más complicado es
 encontrar la forma óptima de hacerlo en Matlab.
 Para ello nos crearemos un vector de coeficientes 
\emph on

\begin_inset Formula $a=[a_{0},a_{1},a_{2},\ldots,a_{N}]^{T}$
\end_inset


\emph default
 
\emph on
ordenado inversamente a como hace Matlab
\emph default
.
 Entonces el polinomio se calcularía con:
\begin_inset Formula \[
p(x)=\sum_{i}a_{i}x^{i}\]

\end_inset


\end_layout

\begin_layout Standard
Un método muy utilizado en estos casos es crear una serie de operadores
 que actúan sobre los coeficientes.
 Estos operadores son distintos para cada caso y se representan como una
 matriz que multiplicará nuestro vector de coeficientes.
 Necesitamos los operadores 
\begin_inset Formula $c\cdot$
\end_inset

,
\begin_inset Formula $\partial_{xx}$
\end_inset

, 
\begin_inset Formula $x^{6}$
\end_inset

y 
\begin_inset Formula $x^{2}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Standard
Nótese que este algoritmo ignora la simetría puesto que tiene en cuenta
 todos los coeficientes, tanto los pares como los impares.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Operador 
\begin_inset Formula $c\cdot$
\end_inset


\end_layout

\begin_layout Standard
El operador de producto por un escalar aplicado a los coeficientes de un
 polinomio es equivalente a:
\begin_inset Formula \[
c\cdot M=c\cdot M_{ij}\]

\end_inset

siendo 
\begin_inset Formula $M$
\end_inset

 una matriz cualquiera la matriz identidad.
\end_layout

\begin_layout Subsection
Operador 
\begin_inset Formula $\partial_{xx}$
\end_inset


\end_layout

\begin_layout Standard
Si tomamos un polinomio:
\begin_inset Formula \[
p(x)=a_{0}+a_{1}x+a_{2}x^{2}+a_{3}x^{3}+\cdots\]

\end_inset

y lo derivamos dos veces respecto a 
\begin_inset Formula $x$
\end_inset

 el resultado será:
\begin_inset Formula \[
\partial_{xx}p(x)=2\cdot1a_{2}+3\cdot2a_{3}x+4\cdot3a_{4}x^{2}+\cdots\]

\end_inset


\end_layout

\begin_layout Standard
El efecto sobre el vector de coeficientes 
\begin_inset Formula $a$
\end_inset

 será hacerlo pasar de 
\begin_inset Formula $a=[a_{0},a_{1},a_{2},a_{3},\ldots]^{T}$
\end_inset

 a 
\begin_inset Formula $\partial_{xx}a=[2\cdot1a_{2},3\cdot2a_{3},4\cdot3a_{4},\ldots]^{T}$
\end_inset

.
 La matriz que representa esta transformación tiene la forma:
\begin_inset Formula \[
\partial_{xx}=\left[\begin{array}{cccccccc}
0 & 0 & 2\cdot1 & 0 & 0 & 0 & \cdots & 0\\
0 & 0 & 0 & 3\cdot2 & 0 & 0 & \cdots & 0\\
0 & 0 & 0 & 0 & 4\cdot3 & 0 & \cdots & 0\\
0 & 0 & 0 & 0 & 0 & 5\cdot4 & \cdots & 0\\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \ddots & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & N(N-1)\end{array}\right]\]

\end_inset


\end_layout

\begin_layout Subsection
Los operadores 
\begin_inset Formula $x^{6}$
\end_inset

y 
\begin_inset Formula $x^{2}$
\end_inset


\end_layout

\begin_layout Standard
Cuando un polinomio
\begin_inset Formula \[
p(x)=a_{0}+a_{1}x+a_{2}x^{2}+a_{3}x^{3}+\cdots\]

\end_inset

es multiplicado por una potencia de su variable los coeficientes se mueven
 hacia las potencias mayores tantas posiciones como sea la potencia de la
 variable.
 La matriz será entonces, para el caso 
\begin_inset Formula $x^{2}$
\end_inset

:
\begin_inset Formula \[
x^{2}=\left[\begin{array}{cccc}
0 & 0 & 0 & \cdots\\
0 & 0 & 0\\
1 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1\\
\vdots &  &  & \ddots\end{array}\right]\]

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
Ejercicio1: Crear tres funciones que generen las matrices correspondientes
 a los operadores 
\begin_inset Formula $\partial_{xx}$
\end_inset

(
\emph on
dxx.m
\emph default
), y 
\begin_inset Formula $x^{n}$
\end_inset

(
\emph on
xn.m
\emph default
) para un vector 
\begin_inset Formula $a$
\end_inset

 de 
\begin_inset Formula $M$
\end_inset

 elementos.
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "80col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
Debe tenerse en cuenta que 
\begin_inset Formula $M=N+1$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Solución:
\emph on

\newline
dxx.m
\end_layout

\begin_layout LyX-Code
function ret=dxx(M)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
%  argumentos:
\end_layout

\begin_layout LyX-Code
%    M :: escalar entero
\end_layout

\begin_layout LyX-Code
%  Retorna el operador derivada segunda para
\end_layout

\begin_layout LyX-Code
%  un vector de coeficientes de tamano M
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
if isscalar(M)
\end_layout

\begin_layout LyX-Code
  ret=[zeros(M-2,1),zeros(M-2,1),diag(2:M-1).*diag(1:M-2)];
\end_layout

\begin_layout LyX-Code
else
\end_layout

\begin_layout LyX-Code
  disp('M debe ser un escalar')
\end_layout

\begin_layout LyX-Code
end
\end_layout

\begin_layout Standard

\emph on
xn.m
\end_layout

\begin_layout LyX-Code
function ret=xn(M,n)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
%  argumentos:
\end_layout

\begin_layout LyX-Code
%    M :: escalar entero
\end_layout

\begin_layout LyX-Code
%    n :: escalar entero
\end_layout

\begin_layout LyX-Code
%  Retorna la matriz correspondiente al operador
\end_layout

\begin_layout LyX-Code
%  x^n con n cualquier exponente entero para un
\end_layout

\begin_layout LyX-Code
%  vector de coeficientes de M elementos
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
if isscalar(M) && isscalar(n)
\end_layout

\begin_layout LyX-Code
  ret=[zeros(n,M);eye(M)];
\end_layout

\begin_layout LyX-Code
else
\end_layout

\begin_layout LyX-Code
  disp ('Ambos argumentos deben ser escalares')
\end_layout

\begin_layout LyX-Code
end
\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Subsection
El operador Residuo.
\end_layout

\begin_layout Standard
Es evidente que los tres operadores anteriores son lineales respecto al
 vector de coeficientes 
\begin_inset Formula $a$
\end_inset

, entonces el operador suma y la multiplicación por un escalar van a tener
 los mismos efectos que en la 
\emph on
realidad:
\emph default

\begin_inset Formula \[
R(a)=\partial_{xx}(a)-x^{6}(a)-3x^{2}(a)\]

\end_inset

van a ser los coeficientes del polinomio del residuo.
\end_layout

\begin_layout Standard
Pero aún no hemos construido nuestro operador Residuo.
 Este es el operador aplicado a un polinomio de la forma usual.
 Nuestro desarrollo en funciones base es ligeramente distinto:
\begin_inset Formula \[
a'=(1-x^{2})a\]

\end_inset

Llamaremos a este operador 
\begin_inset Formula $b$
\end_inset

.
\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
Ejercicio 2: A partir de las funciones anteriores construir el operador
 
\begin_inset Formula $b$
\end_inset

 para un vector 
\begin_inset Formula $a$
\end_inset

 de 
\begin_inset Formula $M$
\end_inset

 elementos.
\end_layout

\begin_layout Standard
La solución a este ejercicio plantea el siguiente problema: Si intentamos
 utilizar la función cdot juntándola con la función 
\emph on
xn
\emph default
 con n=2 aparece el inconveniente de que las matrices no son compatibles.
 Como este problema se va a repetir más adelante crearemos una función que
 adapte las matrices y les añada tantos ceros como sea necesario para hacerlas
 compatibles con la matriz mayor.
 Esta función se llamará 
\emph on
join
\end_layout

\begin_layout Standard
Solución:
\newline

\emph on
join.m
\end_layout

\begin_layout LyX-Code
function ret=join(A,B)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
%  argumentos:
\end_layout

\begin_layout LyX-Code
%  A :: Matriz, real
\end_layout

\begin_layout LyX-Code
%  B :: Matriz, real
\end_layout

\begin_layout LyX-Code
%  Devuelve una copia de la matriz A compatible
\end_layout

\begin_layout LyX-Code
%  con la matriz B en el caso que sean transformaciones
\end_layout

\begin_layout LyX-Code
%  de un vector
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
sizA = size(A);
\end_layout

\begin_layout LyX-Code
sizB = size(B);
\end_layout

\begin_layout LyX-Code
if sizA(2) == sizB(2) && sizA(1) < sizB(1)
\end_layout

\begin_layout LyX-Code
  ret=[A;zeros(sizB(1)-sizA(1),sizA(2))];
\end_layout

\begin_layout LyX-Code
else
\end_layout

\begin_layout LyX-Code
  disp('Las matrices no son compatibles')
\end_layout

\begin_layout LyX-Code
  ret=0;
\end_layout

\begin_layout LyX-Code
end
\end_layout

\begin_layout Standard

\emph on
Creación de la matriz b en función de M:
\end_layout

\begin_layout LyX-Code
function ret=b(M)
\end_layout

\begin_layout LyX-Code
%  argumentos:
\end_layout

\begin_layout LyX-Code
%  M :: escalar entero
\end_layout

\begin_layout LyX-Code
x2 = xn(M,2);
\end_layout

\begin_layout LyX-Code
ret = join(eye(M),x2)-x2;
\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
Para por fin construir el operador residuo utilizaremos la composición de
 aplicaciones lineales, es decir, el producto matricial:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
R(a')=\partial_{xx}(a')-x^{6}(a')-3x^{2}(a')\]

\end_inset


\begin_inset Formula \[
R(a')=(\partial_{xx}\cdot b)(a)-(x^{6}\cdot b)(a)-(3x^{2}\cdot b)(a)\]

\end_inset


\begin_inset Formula \[
R(a')=\left[(\partial_{xx}\cdot b)-(x^{6}\cdot b)-(3x^{2}\cdot b)\right](a)\]

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
Ejercicio 3: Crear a partir de los operadores anteriores la función que
 genere el operador 
\begin_inset Formula $R$
\end_inset

 en función de 
\begin_inset Formula $M$
\end_inset

 teniendo en cuenta que los resultados parciales pueden generar vectores
 de tamaños distintos.
 Esto significa que se va a reproducir el problema que ya encontramos en
 el segundo ejercicio pero esta vez no existe una solución universal.
\end_layout

\begin_layout Standard
Solución:
\newline
R.m
\end_layout

\begin_layout LyX-Code
function ret=R(M)
\end_layout

\begin_layout LyX-Code
% Dificil de descifrar.
  Comentario pendiente
\end_layout

\begin_layout LyX-Code
% Fuciona.
\end_layout

\begin_layout LyX-Code
dxxb = dxx(M+2)*b(M);% Primer termino
\end_layout

\begin_layout LyX-Code
x6b = xn(M+2,6)*b(M);% Segundo termino
\end_layout

\begin_layout LyX-Code
x2_3b = 3*xn(M+2,2)*b(M);% Tercer termino
\end_layout

\begin_layout LyX-Code
ret = join(dxxb,x6b)-x6b-join(x2_3b,x6b);
\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
Definimos 
\begin_inset Formula $a''$
\end_inset

 como 
\begin_inset Formula $a''=R(a)$
\end_inset

, o en forma matricial: 
\begin_inset Formula $a''=R\cdot a$
\end_inset


\end_layout

\begin_layout Subsubsection
Retener los términos independientes:
\end_layout

\begin_layout Standard
Alguien especialmente observador habrá notado que en el operador 
\begin_inset Formula $b$
\end_inset

 parece que falta un término, un 
\begin_inset Formula $+1$
\end_inset

.
 Se ha eliminado de los operadores porque al no ser dependiente de ningún
 coeficiente queda como término independiente.
 Este término debe calcularse a parte
\begin_inset Foot
status collapsed

\begin_layout Standard
Parte de la tarea de la elección de buenas funciones base está en evitar
 que aparezcan estos términos independientes.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Si pasamos este 
\begin_inset Formula $+1$
\end_inset

 por el operador 
\begin_inset Formula $L$
\end_inset

 obtenemos que el término independiente es 
\begin_inset Formula $x^{6}+3x^{2}$
\end_inset

.
\end_layout

\begin_layout Subsection
Sistema de ecuaciones.
\end_layout

\begin_layout Standard
Ahora nos falta igualar el residuo en los puntos de Gauss-Chebyshev a cero.
 Esto da tantas ecuaciones del tipo 
\begin_inset Formula $R(x,a_{i})$
\end_inset

 como sean necesarias.
 Llamando a un punto en concreto 
\begin_inset Formula $\xi_{i}$
\end_inset

 cada ecuación tendrá la forma:
\begin_inset Formula \[
a_{0}^{\prime\prime}+a_{1}^{\prime\prime}\xi_{i}+a_{2}^{\prime\prime}\xi_{i}^{2}+a_{3}^{\prime\prime}\xi_{i}^{3}+\cdots=\xi_{i}^{6}+3\xi^{2}\]

\end_inset

llamamos entonces al sistema:
\begin_inset Formula \[
Sa''=q\]

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
Ejercicio 4: Plantear un sistema de ecuaciones anterior para los puntos:
\begin_inset Formula \[
\xi_{i}=cos\left(\frac{(2i-1)\pi}{2M}\right)\]

\end_inset


\end_layout

\begin_layout Standard
Recordad que el vector 
\begin_inset Formula $a''$
\end_inset

 es de dimensiones diferentes a 
\begin_inset Formula $a$
\end_inset

.
 En el caso que nos ocupa el número de elementos de 
\begin_inset Formula $a''$
\end_inset

 es mayor al de 
\begin_inset Formula $a$
\end_inset

.
 Como el sistema que intentamos resolver en realidad es:
\begin_inset Formula \[
(SR)a=q\]

\end_inset

la matriz del sistema 
\begin_inset Formula $S$
\end_inset

 debe ser compatible con el operador Residuo 
\begin_inset Formula $R$
\end_inset

.
 Para ello, el número de ecuaciones, el número de filas de 
\begin_inset Formula $M$
\end_inset

, debe ser igual al número de elementos de 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Standard
Solución:
\newline

\emph on
SRq.m
\end_layout

\begin_layout LyX-Code
function [S,q]=SRq(R)
\end_layout

\begin_layout LyX-Code
%  calcula la matriz SR en funcion de la matriz residuo R
\end_layout

\begin_layout LyX-Code
% Nodos de Gauss Chebyshev
\end_layout

\begin_layout LyX-Code
% Tomo M de R
\end_layout

\begin_layout LyX-Code
M=size(R)(2); %esto es legal en Octave pero ilegal en Matlab
\end_layout

\begin_layout LyX-Code
              %Octave permite una escritura mucho mas compacta
\end_layout

\begin_layout LyX-Code
ngc=(cos((2*(1:M)-1)*pi/(2*M))).';
\end_layout

\begin_layout LyX-Code
grado=size(R)(1);
\end_layout

\begin_layout LyX-Code
%No hay mas remedio que utilizar un bucle.
\end_layout

\begin_layout LyX-Code
S=R';
\end_layout

\begin_layout LyX-Code
for i=0:grado-1
\end_layout

\begin_layout LyX-Code
  S(:,i+1)=ngc.^i;
\end_layout

\begin_layout LyX-Code
end
\end_layout

\begin_layout LyX-Code
q=ngc.^6+3*ngc.^2;
\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
Ahora sólo nos falta resolver el sistema de ecuaciones final:
\begin_inset Formula \[
(S\cdot R)a=q\]

\end_inset

siendo q el vector de términos independientes que hemos calculado a parte.
\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
Ejercicio 5: Resolver el sistema de ecuaciones para calcular 
\begin_inset Formula $a$
\end_inset

 para 
\begin_inset Formula $M$
\end_inset

=5, 10, 20 y 30.
 Como todo está en función de 
\begin_inset Formula $M$
\end_inset

 no debería haber ningún problema.
\end_layout

\begin_layout Standard
Solución:
\end_layout

\begin_layout LyX-Code
r=R(5);
\end_layout

\begin_layout LyX-Code
[s,q]=SRq(r);
\end_layout

\begin_layout LyX-Code
solM5=(s*r)
\backslash
q;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
r=R(10);
\end_layout

\begin_layout LyX-Code
[s,q]=SRq(r);
\end_layout

\begin_layout LyX-Code
solM10=(s*r)
\backslash
q;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
r=R(20);
\end_layout

\begin_layout LyX-Code
[s,q]=SRq(r);
\end_layout

\begin_layout LyX-Code
solM20=(s*r)
\backslash
q;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
r=R(30);
\end_layout

\begin_layout LyX-Code
[s,q]=SRq(r);
\end_layout

\begin_layout LyX-Code
solM30=(s*r)
\backslash
q;
\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Section
Análisis de los resultados.
\end_layout

\begin_layout Standard
La solución analítica del problema es [Scraton, 1965]:
\begin_inset Formula \[
u(x)=exp\left(\frac{x^{4}-1}{4}\right)\]

\end_inset

Esto nos permite comparar el resultado obtenido con la solución, algo que
 será imposible hacer en la mayoría de los problemas no lineales.
\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
Ejercicio 6: Representar gráficamente la solución analítica junto con cada
 una de las soluciones obtenidas anteriormente.
 Debemos tener en cuenta que los coeficientes que hemos obtenido en el ejercicio
 anterior no son de un polinomio Matlab por dos motivos:
\end_layout

\begin_layout Enumerate
Están almacenados en el orden inverso
\end_layout

\begin_layout Enumerate
El desarrollo polinómico real es de la forma:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
u_{N}(x;a_{i})=1+(1-x^{2})(a_{0}+a_{1}x^{1}+a_{2}x^{2}+\cdots+a_{N}x^{N})\]

\end_inset

Para transformar los coeficientes en el polinomio solución crearemos una
 función llamada 
\emph on
transsol
\emph default
 que nos devolverá el polinomio solución.
\end_layout

\begin_layout Standard
Solución:
\newline
transsol.m
\end_layout

\begin_layout LyX-Code
function ret=transsol(sol)
\end_layout

\begin_layout LyX-Code
%  argumentos
\end_layout

\begin_layout LyX-Code
%    sol :: vector real
\end_layout

\begin_layout LyX-Code
%           vector de coeficientes solucion del problema
\end_layout

\begin_layout LyX-Code
sol=rot90(rot90(sol));
\end_layout

\begin_layout LyX-Code
sol=conv([-1,0,1],sol);
\end_layout

\begin_layout LyX-Code
sol(length(sol))++; % Operador sólo válido en Octave
\end_layout

\begin_layout LyX-Code
ret=sol;                    % proviene de C
\end_layout

\begin_layout Standard
Ahora, para representar gráficamente las soluciones:
\end_layout

\begin_layout LyX-Code
>> x = linspace(-1,1,100);
\end_layout

\begin_layout LyX-Code
>> plot(x,exp((x.^4-1)/4));
\end_layout

\begin_layout LyX-Code
>> hold on
\end_layout

\begin_layout LyX-Code
>> plot(x,polyval(transsol(solM5),x));
\end_layout

\begin_layout LyX-Code
>> plot(x,polyval(transsol(solM10),x));
\end_layout

\begin_layout LyX-Code
>> plot(x,polyval(transsol(solM20),x));
\end_layout

\begin_layout LyX-Code
>> plot(x,polyval(transsol(solM30),x));
\end_layout

\begin_layout Standard
La precisión del resultado es tan alta que no se distinguen las curvas a
 partir de 
\begin_inset Formula $M=10$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ejercicio_espectral_scripts/solucion.eps

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ejercicio_espectral_scripts/error.eps

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Subsection
Convergencia.
\end_layout

\begin_layout Standard
En la mayoría de los casos es imposible saber si la solución que obtenemos
 es la real, lo que sí podemos analizar es si nuestro algoritmo converge
 a una determinada solución.
 La convergencia de los métodos espectrales es, como ya hemos visto, especialmen
te buena.
\end_layout

\begin_layout Standard
Para asegurarnos que la solución converge debemos demostrar que entre los
 términos que obviamos (las potencias mayores) no son lo suficientemente
 relevantes como para influir en la solución.
 Un gráfico especialmente útil es el que representa el logaritmo del módulo
 de los coeficientes en función del número de término que representan.
\end_layout

\begin_layout Standard
Calcularemos tomaremos el caso 
\begin_inset Formula $M=30$
\end_inset

 y representaremos 
\begin_inset Formula $log|a_{n}|$
\end_inset

en función de 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ejercicio_espectral_scripts/convergencia.eps

\end_inset


\end_layout

\begin_layout Standard
Si se toma la tendencia de los coeficientes el problema converge hacia una
 solución.
 Lo más sorprendente es que, como la solución es simétrica, los coeficientes
 impares deberían ser nulos.El mayor coeficiente impar tiene un valor máximo
 equivalente al 
\begin_inset Formula $\epsilon$
\end_inset

del real de doble precisión lo que nos induce a pensar que el error es debido
 a la precisión numérica del método utilizado.
\end_layout

\begin_layout Section
Análisis crítico
\end_layout

\begin_layout Standard
Las soluciones del ejercicio anterior no son perfectas, de hecho, podrían
 ser bastante mejores.
 Se han introducido ciertos errores de estilo a drede para poder analizarlos
 con más detenimiento.
\end_layout

\begin_layout Standard
Un pequeño error es el hecho de utilizar condicionales para los errores
 en las dimensiones de las matrices.
 Si dos argumentos son incompatibles en una operación octave tiene todo
 un sistema de errores dedicado a ello, generar errores no estándar puede
 confundir al usuario al dar información redundante.
 Desde el punto de vista de código tolerante a fallos es más interesante
 una estructura tipo try-catch o una unwind_protect en octave.
\end_layout

\begin_layout Standard
Otro pequeño error es utilizar estructuras en octave que no sean portables.
 Desde el punto de vista de un programador experimentado parece siempre
 una buena idea utilizar todo lo que el lenguaje de programación puede ofrecer
 pero este es un caso especial.
 No es razonable pasar un script a alguien pensando que será capaz de resolver
 la incompatibilidad.
\end_layout

\begin_layout Standard
El problema de las incompatibilidades entre Matlab y Octave es muy grave,
 no porque sean muy distintos sino porque sus diferencias son sutilezas.
 En algunos casos Octave corrige inconsistencias de Matlab o añade posibilidades.
 En otros casos es Matlab el que dispone de una función perfecta para una
 tarea pero no Octave.
 Escribir código portable entre los dos intérpretes no es difícil pero requiere
 haberse leído detenidamente el FAQ del proyecto Octave
\end_layout

\end_body
\end_document
